#!/bin/bash -eu

warn() { echo "$*"; } >&2

parse-args() {
    # Process optional args
    #
    # -h: help
    # -t tagname: name to tag the commit
    # bash lacks good arg parsing
    usage="git addfile [-t tagname | -h] [file-or-dir ...]"
    while getopts ":ht:" opt; do
        case $opt in          
            h) echo "usage: $usage" ; exit 0 ;;
            t) tag=$OPTARG; shift 2;;
            \?) echo "Invalid option: -$OPTARG" >&2; die "$usage" ;;
            :) die "Option -$OPTARG requires an argument." >&2 ;;
        esac
    done
}

add-and-commit() {
    # Add and commit everything new or changed in this directory
    #
    # Normally, these are separate steps,
    # here, we're just cramming stuff in.
    commit_message="$@"                  # capture passed-in commit message
    git add .                            # add everything
    git commit -q -m"$commit_message" || # commit it
		return 1
    if [ "${tag:-}" ]; then              # tag if requested
        git tag $tag
    fi
}

sanity-checks() {
    # Does it make sense to run this script?
    git rev-parse --git-dir &> /dev/null # in a git repo?
}

add-canonical-program() {
    # The classic, hello, world as a shell script
    echo 'echo hello, world' > hello        # create the program
    chmod +x hello                          # make it executable
    add-and-commit "the canonical program"  # commit it
}

create-file-or-directory() {
    # Create the named file/directory
    name=$1                                       # capture passed-in name
    if [ -e "$name" ]; then
		warn "$name already exists"               # tread not on what's there
		return 1
	fi
    if [ ${name:0:1} == '/' ]; then               # first character is a '/'? (`addfile /foo`)
        warn "relative paths only"                # only allow relative paths
		return 1
	fi
    if [ ${name: -1:1} == '/' ]; then             # last character is a '/'? (`addfile foo/`)
        install -d $name ||
			return 1				              # add empty directory
        > $name/.gitkeep                          # empty hidden file because Git ignores empty directories
    else
        install -d $(dirname $name)               # create file in directory
        echo "file $name" > $name                 # real contents
    fi
	return 0
}


# The whole Megillah
if [[ $BASH_SOURCE == $0 ]]; then
	sanity-checks
	parse-args "$@"

	if [ $# -eq 0 ]; then
		add-canonical-program    # we're done!
		exit 0              
	fi

	for name in "$@"; do    # create each name on command line
		create-file-or-directory $name # || die "can't create $name"
	done
	add-and-commit "add elements(s) $@"            # add & commit all
fi
